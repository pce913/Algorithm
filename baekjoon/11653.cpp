#include<stdio.h>
/*
	for문에서 n으로 쓸 수 있는 이유. 밑에서 n/=i 를 하고 난 다음에 새로 얻어지는 n을 nn이라고 하면
	nn의 입장에서도 나타날 수 있는 인수 중에서 가장 큰 값은 루트nn이기 때문이다.
*/
/*
	1. if (n > 1)에서 현재 n보다 더 큰 소인수가 있지 않은 이유. (일단, n이 소수라고 가정하자.)
	 현재의 n은 초기의 n의 루트n값보다 큰 값이다.
	 루트n보다 큰 소인수가 여러개 있다면, 그 수는 이미 n보다 큰 수가 되므로 모순이다.
	 따라서 현재 n보다 더 큰 소인수는 존재하지 않고, 딱 1개만 존재 할 수 있다. 또는 존재 하지 않을수도 있다.

    2. if (n > 1)에서 n이 합성수가 아닌 이유.
	 n은 이미 i로 최대한 나눠진 뒤이기 때문이다. 어떤 수 m = a^2 * b^3 * c 라고 하자. 여기서 c는
	 1번에서 언급한것처럼 루트m보다 큰 딱 하나의 소인수이다. 앞서 for문에서 a^2 와 b^3은 모두 나누어지기 때문에
	 남는것은 c밖에 없다. m=c가 되고 c는 소수이므로 m은 소수이게 된다.
*/
int main(){
	int n;
	scanf("%d",&n);
	for (int i = 2; i*i <= n; i++){
		while (n%i == 0){
			printf("%d\n", i);
			n /= i;
		}
	}
	if (n > 1){
		printf("%d\n",n);      // 예를들어 n=6일 경우에 6의 소인수인 3은 위의 포문에 걸리지 않는다.
	}              //그런 경우에는 딱 하나 이것만 더 출력해주면 된다.
	return 0;
}